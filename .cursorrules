# BAS System Project â€” Cursor AI Tabs

This project uses a **6-tab workflow** for structured feature development. Each tab has a specific role, model, and output format.

#### ðŸ” Refine Mode
If the userâ€™s message **starts with â€œREFINE:â€** or contains questions about the DDR:  
- Temporarily enter **Refine Mode.**  
- Ignore output size limits and table requirements.  
- Respond conversationally to clarify assumptions, design choices, or trade-offs. 

---

## Tab 1: Design (Grok-4)

**Model**: grok-4  
**Purpose**: Create concise Design Decision Records (DDR) with invariants and trade-offs; support interactive refinement when needed.

### Expected Output Size (standard mode)
- **DDR Table**: â‰¤ 8 rows  
- **Summary**: â‰¤ 200 words  
- **Risk List**: exactly 5 items (Top-5 risks)  
- **Total Response**: ~ 400 â€“ 600 tokens  

### Rules
- Output strictly formatted **DDR table** (â‰¤ 8 rows).  
- Each row = `ID | statement | rationale | status | invariant? (Y/N)`.  
- Include â‰¤ 200-word summary + Top-5 risks.  
- **Never** include implementation or code.  
- Focus on **decisions, trade-offs, and constraints.**  
- Keep responses deterministic and within size budgets.  


### Example Prompts

> Draft a Design Decision Record for the new HTTP authentication system. Include invariants for clockless HMAC auth, non-blocking I/O, and retry logic.

> REFINE: Why did we choose async buffering instead of ring buffers, and how does this affect telemetry latency?


---

## Tab 2: Critique (Grok-4 Fast Reasoning)

**Model**: grok-4-fast-reasoning  
**Purpose**: Challenge the DDR to find blind spots, risks, or counterexamples  

### Expected Output Size
- **Bullet Points**: 5 â€“ 12  
- **Each Bullet**: â‰¤ 30 words  
- **Total**: ~ 250 â€“ 400 tokens  

### Rules
- Review only the DDR decision table and risk list.  
- Output â‰¤ 12 bullets (risks, blind spots, counterexamples).  
- **No** re-writing or re-designing.  
- Be adversarial but constructive; focus on failure modes.

### Example Prompt

> Review this DDR and list edge cases that could break auth or cause network lockups. Keep your response to 10 concise bullets.


---

## Tab 3: Implementation Plan (Grok-4)

**Model**: grok-4  
**Purpose**: Convert approved DDR into structured Patch Plan with files, signatures, tests, and budgets  

### Expected Output Size
- **Patch Plan Table**: â‰¤ 12 rows  
- **Summary**: â‰¤ 100 words (optional)  
- **Notes**: â‰¤ 50 words per note  
- **Total**: ~ 400 â€“ 700 tokens  

### Rules
- Generate **Patch Plan** (â‰¤ 12 rows).  
- Each row = `file | op | functions/APIs | tests | perf/mem budget | risk`.  
- **No** prose or speculative design.  
- Focus on concrete, actionable changes with budgets and tests.

### Example Prompt

> Create a Patch Plan to implement the approved DDR for non-blocking SSE and auth token verification.


---

## Tab 4: Implement (Grok Code Fast)

**Model**: grok-code-fast-1  
**Purpose**: Write or modify code via unified diffs from the Patch Plan  

### Expected Output Size
- **Unified Diff**: one per logical change (â‰ˆ 10â€“50 lines)  
- **Explanation**: â‰¤ 50 words per change  
- **Test Checklist**: 3 â€“ 5 items  
- **Total**: ~ 300 â€“ 800 tokens  

### Rules
- Generate **unified git patches** only (one per logical change).
- Include short checklist: `pytest â†’ mpremote deploy â†’ device smoke`.
- **Never** regenerate whole files unless explicitly asked.
- Keep diffs small and focused; prefer incremental changes.
- Include line numbers in patches.
- Execute one row at a time in order; do not skip or batch rows.
- Before coding each row:
- Summarize the intended change, files to touch, and rationale.
- Show a proposed diff/plan (what will be added/removed/modified).
- Confirm I fully understand and explicitly get my approval.
- After approval: implement only the changes for that row.
- Present the actual diff, run tests/linters for the touched scope, and report results.
- Pause for my review; do not proceed to the next row without my consent.

### Example Prompt

> Apply Patch Plan row #3 (network/sse.py). Implement non-blocking SSE with 20 s heartbeat and jittered reconnects. Output a unified diff.


---

## Tab 5: Triage (Grok-4 Fast Non-Reasoning)

**Model**: grok-4-fast-non-reasoning  
**Purpose**: Parse test or runtime logs into concise TODO lists  

### Expected Output Size
- **TODO/Fixlist**: â‰¤ 10 items  
- **Each Item**: â‰¤ 25 words  
- **Root Cause Summary**: â‰¤ 50 words  
- **Total**: ~ 200 â€“ 350 tokens  

### Rules
- Input = test or device logs.  
- Output = actionable TODO/fixlist (â‰¤ 10).  
- Parse logs into root causes and rank by impact.  
- No speculationâ€”only observed issues.

### Example Prompt

> Parse this pytest output. Summarize root causes and list fixes ranked by impact.


---

## Tab 6: Sweep (Grok-4)

**Model**: grok-4  
**Purpose**: Audit changed App/Net files for regressions or blocking code  

### Expected Output Size
- **Audit Summary**: â‰¤ 100 words  
- **Issues Table**: one row per issue  
- **Each Issue**: file path + line number + issue type + severity  
- **Total**: ~ 300 â€“ 600 tokens  

### Rules
- Audit only changed files in `application/`, `network/`, or `services/`.  
- Search for blocking I/O, missing timeouts, unbounded buffers, auth bypass.  
- Output brief summary and tabular issues list with severity.

### Example Prompt

> Audit all changed files for blocking socket calls and missing timeout handling. Return a short table of issues found.


---

## Handoff Format Between Tabs

[Summary â‰¤ 120 w]
[Decisions â‰¤ 8 rows: ID | statement | rationale | status | invariant?]
[Top-5 Risks (one-liners)]
[Patch Plan excerpt â‰¤ 12 rows or 'pending']


---

## Tab Workflow
1. **Design** â†’ Draft DDR (Grok-4)  
2. **Critique** â†’ Review DDR (Grok-4 Fast Reasoning)  
3. **Impl Plan** â†’ Build Patch Plan (Grok-4)  
4. **Critique (optional)** â†’ Validate Patch Plan (Grok-4 Fast Reasoning)  
5. **Implement** â†’ Write code diffs (Grok Code Fast)  
6. **Triage** â†’ Parse logs (Grok-4 Fast Non-Reasoning)  
7. **Sweep (optional)** â†’ Audit changed modules (Grok-4)
